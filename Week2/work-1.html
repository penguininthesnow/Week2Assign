<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>work-1 作業一</title>
</head>
<body>
    <script>
    const positions = {
    "悟空": [0, 0],
    "丁滿":[-1, 4],
    "辛巴":[-3, 3],
    "貝吉塔":[-4, -1],
    "弗利沙":[4, -1],
    "特南克斯":[1, -2],

}

// 斜線 假設 y=-x+2
const LINE_A = 1.0
const LINE_B = 1.0
const LINE_C = -2.0

function same_side(p1, p2, a, b, c){
    const v1=a*p1[0]+b*p1[1]+c ;
    const v2=a*p2[0]+b*p2[1]+c ;
    if (v1=== 0 || v2 === 0)
        return true ;
    return v1*v2>0 ; //同號表示在同一側
}
    
    

function cross_line(p1, p2, a, b, c, cheat=2){
    const dx= Math.abs(p1[0] - p2[0]);
    const dy= Math.abs(p2[1] - p2[1]);
    let cor = dx + dy;  // 同側則回傳 cor
    if (!same_side) cor += cheat; // 不同側代表有跨越 要+2(cheat)
        return cor
}

function func1(name){
    if (!(name in positions)) {
        console.log(" 角色不存在 ")
        return
    }
    const target = positions[name];
    const dists = {};

    for(const [other, pos] of Object.entries(positions))  {
        if (other === name) continue;
        const  d = cross_line(target, pos, LINE_A, LINE_B, LINE_C , 2);
        dists[ other ] = d;
    }
    const distances= Object.values(dists);
    const min_d = Math.min(...distances);
    const max_d = Math.max(...distances);

    const nearest = Object.keys(dists). filter(k=> dists[k] === min_d);
    const farthest = Object.keys(dists). filter(k=> dists[k] === max_d)

    console.log(`${name} -> 最遠( 距離${max_d} ): ${farthest.join("、")} ;最近( 距離${min_d} ): ${nearest.join("、")}`);
    
}
    
func1("辛巴");
func1("悟空");
func1("弗利沙");
func1("特南克斯");
        

    </script>
</body>
</html>